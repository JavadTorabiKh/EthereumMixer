# ğŸŒ€ Ethereum Mixer - A Tornado-like Mixer in Solidity & Python

An Ethereum mixer smart contract built with **Solidity** and **Python**, designed to enhance transaction privacy using **Merkle Trees** and **zkSNARKs**. Inspired by [Tornado Cash](https://tornado.cash), this project aims to demonstrate how zero-knowledge cryptography can enable anonymous transactions on Ethereum.

---

## ğŸ“Œ What is an Ethereum Mixer?

An Ethereum mixer (also known as a tumbler) allows users to deposit and withdraw cryptocurrency in a way that **breaks the on-chain link** between sender and receiver, enabling **privacy** in a fully transparent blockchain environment.

---

## ğŸ§± Types of Ethereum Mixers

Before diving into the implementation, it's important to understand the different architectural models for mixers:

### 1. Simple Mixer (Direct Deposit & Withdraw)
- Users deposit and later withdraw funds.
- ğŸŸ  **Low privacy** â€“ deposits and withdrawals are easily correlated.

### 2. Timed Mixer
- Funds are locked for a period before becoming withdrawable.
- ğŸŸ¡ **Moderate privacy** â€“ makes timing correlation harder.

### 3. Hashed Commitments
- Users deposit a hash of a secret.
- Later, the secret is revealed for withdrawal.
- ğŸŸ¡ **Moderate privacy** â€“ no direct address linkage, but patterns still traceable.

### 4. âœ… Merkle Tree + zkSNARKs (Tornado-Style)
- Users deposit a commitment added to a Merkle Tree.
- Withdrawals are done using **zkSNARK proofs** to show knowledge of a valid (but unspent) commitment.
- ğŸŸ¢ **High privacy** â€“ no address or amount linkage, full anonymity.

---

## ğŸ” How the Tornado-Style Mixer Works

### ğŸ§© Core Components

- **Merkle Tree:** Stores all deposit commitments.
- **Commitment:** A hash of a secret (e.g., `hash(nullifier, secret)`).
- **Nullifier:** Prevents double withdrawals by keeping track of spent commitments.
- **zkSNARK Proof:** Proves that the user knows a valid commitment without revealing it.

### ğŸ”„ Workflow

#### 1. Deposit
- Generate a random `nullifier` and `secret`.
- Compute `commitment = hash(nullifier, secret)`.
- Submit `deposit(commitment)` to the smart contract.
- Commitment is added to the Merkle Tree.

#### 2. Withdraw
- Generate a zkSNARK proof that:
  - Your commitment exists in the Merkle Tree.
  - You haven't withdrawn it before (nullifier is unused).
- Call `withdraw(proof, root, nullifierHash, recipient)`.

---

## ğŸ§° Tech Stack

### ğŸ’» Smart Contracts
- **Solidity** for writing the Mixer and Verifier contracts.
- **Hardhat** or **Foundry** for development & testing.

### ğŸ§ª zkSNARKs
- **circom**: DSL for writing zk circuits.
- **snarkjs**: CLI tool for circuit compilation, proving & verifying.
- **Poseidon Hash**: Efficient zk-friendly hashing.

### ğŸ Python (Optional Tooling)
- For handling:
  - Circuit input generation
  - Merkle Tree operations
  - Account/key management
  - Proof generation automation using subprocess

---

## ğŸ—‚ï¸ Suggested Project Structure

```bash
    ethereum-mixer/
    â”‚
    â”œâ”€â”€ contracts/
    â”‚ â”œâ”€â”€ Mixer.sol # Main mixer contract
    â”‚ â””â”€â”€ Verifier.sol # zkSNARK verifier contract
    â”‚
    â”œâ”€â”€ circuits/
    â”‚ â””â”€â”€ mixer.circom # zkSNARK circuit
    â”‚
    â”œâ”€â”€ scripts/
    â”‚ â””â”€â”€ generate_proof.py # Python script to generate proof
    â”‚
    â”œâ”€â”€ merkle/
    â”‚ â””â”€â”€ merkle_tree.py # Python Merkle Tree helper
    â”‚
    â”œâ”€â”€ test/
    â”‚ â””â”€â”€ test_mixer.py # Python or Hardhat tests
    â”‚
    â”œâ”€â”€ hardhat.config.js
    â””â”€â”€ README.md

```